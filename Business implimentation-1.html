<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Algorithms Showcase</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #727070;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1000px;
            margin: 50px auto;
            padding: 20px;
            background: white;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        textarea {
            width: 100%;
            height: 600px;
            margin-bottom: 20px;
            padding: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
            resize: none;
        }
        label {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: block;
        }
        input, button, textarea {
            font-family: Arial, sans-serif;
        }
        button {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            color: white;
            background: #007BFF;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .output {
            margin-top: 20px;
            padding: 15px;
            background: #707070;
            border: 1px solid #ddd;
            border-radius: 5px;
            white-space: pre-wrap;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Project Implimentation</h1>

        <label for="codeArea">Full C++ Code:</label>
        <textarea id="codeArea" readonly>
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <string>
#include <climits>
using namespace std;

// Dijkstra's Algorithm: Shortest Path
void dijkstra(vector<vector<pair<int, int>>> &graph, int source) {
    int n = graph.size();
    vector<int> dist(n, INT_MAX);
    dist[source] = 0;

    // Min-Heap Priority Queue
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
    pq.push({0, source});

    while (!pq.empty()) {
        int cost = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        for (auto &[v, weight] : graph[u]) {
            if (cost + weight < dist[v]) {
                dist[v] = cost + weight;
                pq.push({dist[v], v});
            }
        }
    }

    cout << "Dijkstra's Shortest Path from Node " << source << ":\n";
    for (int i = 0; i < n; i++) {
        cout << "Node " << i << ": " << (dist[i] == INT_MAX ? "INF" : to_string(dist[i])) << '\n';
    }
}

// AVL Tree: Insertion and Balancing
struct AVLNode {
    int key;
    AVLNode *left, *right;
    int height;

    AVLNode(int val) : key(val), left(nullptr), right(nullptr), height(1) {}
};

int height(AVLNode *node) {
    return node ? node->height : 0;
}

int balanceFactor(AVLNode *node) {
    return node ? height(node->left) - height(node->right) : 0;
}

AVLNode* rotateRight(AVLNode *y) {
    AVLNode *x = y->left;
    AVLNode *T = x->right;

    x->right = y;
    y->left = T;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

AVLNode* rotateLeft(AVLNode *x) {
    AVLNode *y = x->right;
    AVLNode *T = y->left;

    y->left = x;
    x->right = T;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

AVLNode* insert(AVLNode *node, int key) {
    if (!node) return new AVLNode(key);

    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else
        return node; // No duplicates allowed

    node->height = 1 + max(height(node->left), height(node->right));
    int balance = balanceFactor(node);

    // Left-Left Case
    if (balance > 1 && key < node->left->key)
        return rotateRight(node);

    // Right-Right Case
    if (balance < -1 && key > node->right->key)
        return rotateLeft(node);

    // Left-Right Case
    if (balance > 1 && key > node->left->key) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    // Right-Left Case
    if (balance < -1 && key < node->right->key) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    return node;
}

void preOrder(AVLNode *root) {
    if (root) {
        cout << root->key << " ";
        preOrder(root->left);
        preOrder(root->right);
    }
}

// KMP String Matching Algorithm
void computeLPSArray(string pattern, vector<int> &lps) {
    int length = 0;
    int i = 1;
    lps[0] = 0;

    while (i < pattern.length()) {
        if (pattern[i] == pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMP(string text, string pattern) {
    int m = pattern.length();
    int n = text.length();

    vector<int> lps(m);
    computeLPSArray(pattern, lps);

    int i = 0, j = 0;

    while (i < n) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }

        if (j == m) {
            cout << "Pattern found at index " << i - j << '\n';
            j = lps[j - 1];
        } else if (i < n && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

// Segment Tree: Range Sum Query
class SegmentTree {
    vector<int> tree;
    int n;

public:
    SegmentTree(vector<int> &arr) {
        n = arr.size();
        tree.resize(4 * n);
        buildTree(arr, 0, n - 1, 0);
    }

    void buildTree(vector<int> &arr, int start, int end, int node) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }

        int mid = (start + end) / 2;
        buildTree(arr, start, mid, 2 * node + 1);
        buildTree(arr, mid + 1, end, 2 * node + 2);
        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }

    int query(int l, int r, int start, int end, int node) {
        if (l > end || r < start) return 0;
        if (l <= start && r >= end) return tree[node];

        int mid = (start + end) / 2;
        return query(l, r, start, mid, 2 * node + 1) +
               query(l, r, mid + 1, end, 2 * node + 2);
    }

    int rangeSum(int l, int r) {
        return query(l, r, 0, n - 1, 0);
    }
};

int main() {
    cout << "Algorithm Case Study\n\n";

    // Dijkstra's Algorithm Example
    vector<vector<pair<int, int>>> graph = {
        {{1, 2}, {2, 4}},
        {{2, 1}},
        {{3, 5}},
        {}
    };
    dijkstra(graph, 0);

    // AVL Tree Example
    AVLNode *root = nullptr;
    vector<int> avlValues = {10, 20, 30, 40, 50, 25};
    for (int val : avlValues) {
        root = insert(root, val);
    }
    cout << "\nAVL Tree Preorder Traversal:\n";
    preOrder(root);

    // KMP String Matching Example
    cout << "\n\nKMP String Matching:\n";
    string text = "ababcabcabababd";
    string pattern = "ababd";
    KMP(text, pattern);

    // Segment Tree Example
    cout << "\nSegment Tree Range Sum Query:\n";
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree st(arr);
    cout << "Sum of range [1, 3]: " << st.rangeSum(1, 3) << '\n';

    return 0;
}
        </textarea>

        <button onclick="runCode()">Run Code</button>

        <div id="outputField" class="output">
            Output will appear here...
        </div>
    </div>

    <script>
        function runCode() {
            const outputField = document.getElementById("outputField");

            // Predefined output from the C++ code
            const output = `
Dijkstra's Shortest Path from Node 0:
Node 0: 0
Node 1: 2
Node 2: 3
Node 3: 8

AVL Tree Preorder Traversal:
30 20 10 25 40 50

KMP String Matching:
Pattern found at index 10

Segment Tree Range Sum Query:
Sum of range [1, 3]: 15
            `;

            outputField.innerText = output;
        }
    </script>
</body>
</html>
